#[cfg(test)]
mod tests {
    use anochi::{CodeRunner, vm::TestBackend};

    #[test]
    fn test_interactive_backend_simulation() {
        let mut test_backend = TestBackend::new();
        
        // Test backend input queue and calculator operations
        test_backend.add_input("10".to_string());
        test_backend.add_input("5".to_string());
        test_backend.add_input("Hello World".to_string());
        
        let mut runner = CodeRunner::with_backend(test_backend);
        
        // Test calculator operations with debug output
        runner.run("a = 10; b = 5;").unwrap();
        runner.run("sum = a + b; debug(\"Sum:\", sum);").unwrap();
        runner.run("product = a * b; debug(\"Product:\", product);").unwrap();
        runner.run(r#"message = "Hello World"; debug("Message:", message);"#).unwrap();
        
        let output = runner.vm().backend().get_debug_output();
        assert!(output.contains("Sum:"));
        assert!(output.contains("15")); // 10 + 5
        assert!(output.contains("Product:"));
        assert!(output.contains("50")); // 10 * 5
        assert!(output.contains("Hello World"));
        
        // Test input queue length
        assert_eq!(test_backend.input_queue_len(), 3);
    }

    #[test]
    fn test_input_type_auto_detection() {
        // Test the type detection logic that would be used by the VM
        let test_cases = vec![
            ("42", "Integer"),
            ("3.14159", "Float"),
            ("true", "Bool"),
            ("false", "Bool"),
            ("hello world", "String"),
            ("123.0", "Float"),
            ("-42", "Integer"),
            ("-3.14", "Float"),
        ];
        
        for (input, expected_type) in test_cases {
            let detected_type = if input.parse::<i64>().is_ok() {
                "Integer"
            } else if input.parse::<f64>().is_ok() {
                "Float"
            } else if input == "true" || input == "false" {
                "Bool"
            } else {
                "String"
            };
            
            assert_eq!(detected_type, expected_type, "Failed for input: {input}");
        }
    }

    #[test]
    fn test_mixed_data_types_debug() {
        let test_backend = TestBackend::new();
        let mut runner = CodeRunner::with_backend(test_backend);
        
        // Test mixed data types and debug output accumulation
        runner.run("int_val = 42;").unwrap();
        runner.run("float_val = 3.14;").unwrap();
        runner.run("bool_val = true;").unwrap();
        runner.run(r#"string_val = "test";"#).unwrap();
        
        runner.run("debug(\"Mixed types:\", int_val, float_val, bool_val, string_val);").unwrap();
        runner.run("debug(\"Multiple lines\", \"work correctly\");").unwrap();
        
        let output = runner.vm().backend().get_debug_output();
        assert!(output.contains("Mixed types:"));
        assert!(output.contains("42"));
        assert!(output.contains("3.14"));
        assert!(output.contains("true"));
        assert!(output.contains("test"));
        assert!(output.contains("Multiple lines"));
        
        // Verify multiple debug statements accumulate
        let lines: Vec<&str> = output.lines().collect();
        assert!(lines.len() >= 2);
    }
}
